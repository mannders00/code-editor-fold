{"version":3,"sources":["webpack://sn-code-editor-fold/./src/main.js"],"names":["document","addEventListener","modeByModeMode","CodeMirror","modeInfo","reduce","acc","m","mode","push","modeModeAndMimeByName","name","mime","modes","Object","keys","componentRelay","workingNote","clientData","lastValue","lastUUID","editor","select","ignoreTextChange","initialLoad","save","note","folds","saveFolds","saveItemWithPresave","getValue","content","text","preview_plain","preview_html","doc","getDoc","marks","getAllMarks","length","i","collapsed","type","find","from","changeMode","inputMode","convertCodeMirrorMode","codeMirrorMode","extension","exec","test","findModeByExtension","findModeByMIME","firstMode","inputModeToMode","setOption","autoLoadMode","getElementById","selectedIndex","indexOf","console","error","updateVimStatus","keyMap","toggleButton","newAction","buttonClass","innerHTML","classList","remove","add","window","setKeyMap","keymap","onLanguageSelect","setDefaultLanguage","language","setComponentDataValueForKey","message","original","setTimeout","toggleVimMode","newKeyMap","getComponentDataValueForKey","commands","fromTextArea","extraKeys","lineNumbers","styleSelectedText","lineWrapping","foldGutter","gutters","cm","toggleFold","foldAll","unfoldAll","setSize","index","option","createElement","value","appendChild","createSelectElements","on","ComponentRelay","targetWindow","onReady","platform","body","initialKeyMap","streamContextItem","uuid","isMetadataUpdate","setValue","foldCode","restoreFolds","clearHistory","onReceivedNote"],"mappings":"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","file":"main.js","sourcesContent":["document.addEventListener(\"DOMContentLoaded\", function () {\n\n  const modeByModeMode = CodeMirror.modeInfo.reduce(function (acc, m) {\n    if (acc[m.mode]) {\n      acc[m.mode].push(m)\n    } else {\n      acc[m.mode] = [m]\n    }\n    return acc;\n  }, {});\n\n  const modeModeAndMimeByName = CodeMirror.modeInfo.reduce(function (acc, m) {\n    acc[m.name] = { mode: m.mode, mime: m.mime };\n    return acc;\n  }, {});\n\n  const modes = Object.keys(modeModeAndMimeByName);\n\n  let componentRelay;\n  let workingNote, clientData;\n  let lastValue, lastUUID;\n  let editor, select;\n  const defaultMode = \"Markdown\";\n  let ignoreTextChange = false;\n  let initialLoad = true;\n\n  function loadComponentRelay() {\n    componentRelay = new ComponentRelay({\n      targetWindow: window,\n      onReady: () => {\n        const platform = componentRelay.platform;\n        if (platform) {\n          document.body.classList.add(platform);\n        }\n        const initialKeyMap = componentRelay.getComponentDataValueForKey(\"keyMap\") ?? \"default\";\n        window.setKeyMap(initialKeyMap);\n        updateVimStatus(initialKeyMap, true);\n      }\n    });\n\n    componentRelay.streamContextItem((note) => {\n      onReceivedNote(note);\n    });\n  }\n\n  function save() {\n    if (workingNote) {\n      // Be sure to capture this object as a variable, as this.note may be reassigned in `streamContextItem`, so by the time\n      // you modify it in the presave block, it may not be the same object anymore, so the presave values will not be applied to\n      // the right object, and it will save incorrectly.\n      let note = workingNote;\n      let folds = saveFolds();\n\n      componentRelay.saveItemWithPresave(note, () => {\n        lastValue = editor.getValue();\n        note.content.text = lastValue;\n        note.clientData = clientData;\n\n        note.content.folds = folds;\n\n        note.content.preview_plain = null;\n        note.content.preview_html = null;\n      });\n    }\n  }\n\n  function saveFolds() {\n    if(editor){\n      doc = editor.getDoc();\n      marks = doc.getAllMarks();\n      folds = [];\n      if(marks.length){\n        for(var i = marks.length - 1; i >= 0; i--){\n          if(marks[i].collapsed && (marks[i].type === 'range')){\n            folds.push(marks[i].find().from);\n          }\n        }\n      }\n      return folds;\n    }\n  }\n\n  function restoreFolds(note) {\n    if(note && 'folds' in note.content){\n      folds = note.content.folds;\n      for (var i = 0; i < folds.length; ++i){\n        editor.foldCode(folds[i]);\n      }\n    }\n  }\n\n  function onReceivedNote(note) {\n    if (note.uuid !== lastUUID) {\n      // Note changed, reset last values\n      lastValue = null;\n      initialLoad = true;\n      lastUUID = note.uuid;\n    }\n\n    workingNote = note;\n    // Only update UI on non-metadata updates.\n    if (note.isMetadataUpdate) {\n      return;\n    }\n\n    clientData = note.clientData;\n    const mode = clientData.mode;\n\n    if (mode) {\n      changeMode(mode);\n    } else {\n      // assign editor's default from component settings\n      let defaultLanguage = componentRelay.getComponentDataValueForKey(\"language\");\n      changeMode(defaultLanguage);\n    }\n\n    if (editor) {\n      if (note.content.text !== lastValue) {\n        ignoreTextChange = true;\n        editor.getDoc().setValue(workingNote.content.text);\n        ignoreTextChange = false;\n      }\n\n      setTimeout(function () {\n        restoreFolds(workingNote);\n      }, 100);\n\n      if (initialLoad) {\n        initialLoad = false;\n        editor.getDoc().clearHistory();\n      }\n    }\n  }\n\n  function loadEditor() {\n    // Handler for the save command that is mapped to the :w (write) Vim key binding.\n    CodeMirror.commands.save = function() {\n      save();\n    };\n    editor = CodeMirror.fromTextArea(document.getElementById(\"code\"), {\n      extraKeys: {\n        'Alt-F': 'findPersistent',\n      },\n      lineNumbers: true,\n      styleSelectedText: true,\n      lineWrapping: true,\n      foldGutter: true,\n      gutters: [\"CodeMirror-linenumbers\", \"CodeMirror-foldgutter\"]\n    });\n    editor.setOption(\"extraKeys\", {\n      \"Ctrl-F\": cm => (CodeMirror.commands.toggleFold(cm), save()),\n      \"Ctrl-W\": cm => (CodeMirror.commands.foldAll(cm), save()),\n      \"Ctrl-Q\": cm => (CodeMirror.commands.unfoldAll(cm), save()),\n    })\n    editor.setSize(\"100%\", \"100%\");\n\n    setTimeout(function () {\n      changeMode(defaultMode);\n    }, 1);\n\n    createSelectElements();\n\n    editor.on(\"change\", function() {\n      if (ignoreTextChange) {\n        return;\n      }\n      save();\n    });\n    editor.on(\"gutterClick\", function() {\n      save();\n    });\n\n  }\n\n  function createSelectElements() {\n    select = document.getElementById(\"language-select\");\n    for (let index = 0; index < modes.length; index++) {\n      const option = document.createElement(\"option\");\n      option.value = index;\n      option.innerHTML = modes[index];\n      select.appendChild(option);\n    }\n  }\n\n  // Editor Modes\n  window.setKeyMap = function (keymap) {\n    editor.setOption(\"keyMap\", keymap);\n  }\n\n  window.onLanguageSelect = function () {\n    const language = modes[select.selectedIndex];\n    changeMode(language);\n    save();\n  }\n\n  window.setDefaultLanguage = function () {\n    const language = modes[select.selectedIndex];\n\n    // assign default language for this editor when entering notes\n    componentRelay.setComponentDataValueForKey(\"language\", language);\n\n    // show a confirmation message\n    const message = document.getElementById(\"default-label\");\n    const original = message.innerHTML;\n    message.innerHTML = \"Success\";\n    message.classList.add(\"success\");\n\n    setTimeout(function () {\n      message.classList.remove(\"success\");\n      message.innerHTML = original;\n    }, 750);\n  }\n\n  function inputModeToMode(inputMode) {\n    const convertCodeMirrorMode = function (codeMirrorMode) {\n      if (codeMirrorMode) {\n        return {\n          name: codeMirrorMode.name,\n          mode: codeMirrorMode.mode,\n          mime: codeMirrorMode.mime\n        };\n      } else {\n        return null;\n      }\n    };\n\n    const extension = /.+\\.([^.]+)$/.exec(inputMode);\n    const mime = /\\//.test(inputMode)\n\n    if (extension) {\n      return convertCodeMirrorMode(CodeMirror.findModeByExtension(extension[1]));\n    } else if (mime) {\n      return convertCodeMirrorMode(CodeMirror.findModeByMIME(mime[1]));\n    } else if (modeModeAndMimeByName[inputMode]) {\n      return {\n        name: inputMode,\n        mode: modeModeAndMimeByName[inputMode].mode,\n        mime: modeModeAndMimeByName[inputMode].mime\n      };\n    } else if (modeByModeMode[inputMode]) {\n      const firstMode = modeByModeMode[inputMode][0];\n      return {\n        name: firstMode.name,\n        mode: firstMode.mode,\n        mime: firstMode.mime\n      };\n    } else {\n      return {\n        name: inputMode,\n        mode: inputMode,\n        mime: inputMode\n      };\n    }\n  }\n\n  function changeMode(inputMode) {\n    if (!inputMode) { return; }\n\n    const mode = inputModeToMode(inputMode);\n\n    if (mode) {\n      editor.setOption(\"mode\", mode.mime);\n      CodeMirror.autoLoadMode(editor, mode.mode);\n      if (clientData) {\n        clientData.mode = mode.name;\n      }\n      document.getElementById(\"language-select\").selectedIndex = modes.indexOf(mode.name);\n    } else {\n      console.error(\"Could not find a mode corresponding to \" + inputMode);\n    }\n  }\n\n  function updateVimStatus(keyMap) {\n    const toggleButton = document.getElementById(\"toggle-vim-mode-button\");\n\n    const newAction = keyMap === \"vim\" ? \"Disable\" : \"Enable\";\n    const buttonClass = keyMap === \"vim\" ? \"danger\" : \"success\";\n\n    toggleButton.innerHTML = `${newAction} Vim mode`;\n    toggleButton.classList.remove('danger');\n    toggleButton.classList.remove('success');\n    toggleButton.classList.add(buttonClass);\n  }\n\n  window.toggleVimMode = function() {\n    let newKeyMap;\n\n    const currentKeyMap = componentRelay.getComponentDataValueForKey(\"keyMap\") ?? \"default\";\n    if (currentKeyMap === \"default\") {\n      newKeyMap = \"vim\";\n    } else {\n      newKeyMap = \"default\";\n    }\n\n    window.setKeyMap(newKeyMap);\n    componentRelay.setComponentDataValueForKey(\"keyMap\", newKeyMap);\n\n    updateVimStatus(newKeyMap);\n  }\n\n  loadEditor();\n  loadComponentRelay();\n});\n"],"sourceRoot":""}